# Guide for writing frontend tests

## What are automated tests?
- Automated tests are dedicated code blocks that run to ensure a system works correctly.
- Automating tests reduces the need for humans to verify correctness.
- Tests can be done at any granularity level of a stack: the Oppia app, a specific class, or even a specific method.
- Tests prevent regressions which helps ensure your code doesn't break your teammates (and who wants to be remembered as the person who breaks everyone's code?).
- Tests also provide satisfaction & confidence when they verify that your code was written correctly.

## What are the various types of tests?
The most popular tests include unit tests, integration testing, end-to-end (e2e) tests, and manual tests. In Oppia Frontend, we write unit tests using Karma. Currently, we don’t really write integration tests in the frontend, but we do write e2e tests using Protractor. Apart from this every month, we do manual testing of the critical features every monthly release. 

## What are unit tests?
- A unit test verifies a particular behaviour of a small component, for example, the component would be a function, and the behaviour would be the functionality under a particular set of inputs. 
- A unit test should be dependent only on the functionality being tested. It should be independent of other functionalities.
- A unit test typically has 3 parts
     - Setup: This is the place where you create variables, dependencies, etc. 
     - Action: This part performs the logic to be tested. 
     - Assertions: Here you add commands to verify that the above action was completed (or not completed) as expected. 
- [Here](https://github.com/oppia/oppia/blob/17b6e0ff1fc6b88687af92376cb90bf5f247e539/core/templates/dev/head/domain/skill/RubricObjectFactorySpec.ts#L28-L41) is a simple unit test that demonstrates these points.


## Best practices for good tests:
- Naming the test is important. The name should include the name of the component being tested, the conditions imposed on the test and the expected outcome of the test. 
    - The test name follows this format: describe(<component name>) and it(‘should <do this action> when <this condition is imposed>’)
- Use `fdescribe` instead of the outter `describe` when testing on development environment, so only the file you're testing will be considered on karma running. All the frontend files are related by many ways, like dependency injection for example. It could happen one file already be testing the file you're testing. This is to be sure that the test file is covering all the code from the respective file, in despite of other files. Just be sure to change it again to `describe` when commit changes.
- All possible code paths in the function should be tested. This is important from a coverage perspective. [Here](https://github.com/oppia/oppia/blob/develop/core/templates/dev/head/domain/objects/FractionObjectFactorySpec.ts) is a good example of testing all code paths
- Any common code can be extracted into a helper function to reduce duplication. Make sure the helper function deals with only one of the 3 parts, ie, the helper function can help with either setup, action or assertion, avoid overlapping across the parts.
- Assert as many things as possible. An example of this is say, the function returns the list, you can assert that the number of elements is as expected, and each element you expect is in the list. Another example is if an object is expected, then assert the various fields of the object are as expected.
- In the frontend, while writing tests, we don’t make actual calls to the backend. All http calls are mocked, to keep the tests independent of the backend. Similarly, any services can also be mocked. We try to keep such mocks as low as possible. [Here](https://github.com/oppia/oppia/blob/develop/core/templates/dev/head/domain/learner_dashboard/learner-playlist.service.spec.ts#L27) is an example usage of $httpBackend to mock the backend responses.
- When writing asynchronous tests, always have an argument `done` in the test and call `done()` at the end of the asynchronous function. An example is shown below.
```typescript
  it('should correctly check if language supports autogenerated audio',
    (done) => {
      // Chrome loads voices asynchronously.
      // https://stackoverflow.com/questions/21513706/
      // Chrome also calls this multiple times and not all languages are
      // populated the first time, see
      // https://developer.mozilla.org/en-US/docs/Web/API/SpeechSynthesis
      // for more details. In the case where all languages are loaded
      // the first time, the test will complete in one pass successfully.
      window.speechSynthesis.onvoiceschanged = () => {
        if (window.speechSynthesis.getVoices().length > 0) {
          expect(lus.supportsAutogeneratedAudio('hi')).toEqual(false);
          expect(lus.supportsAutogeneratedAudio('en')).toEqual(true);
          done();
        }
      };
    });
```